"use strict";(self.webpackChunkpmdaemon_docs=self.webpackChunkpmdaemon_docs||[]).push([[7871],{1785:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api/library-usage","title":"Library Usage","description":"PMDaemon can be used as a Rust library, allowing you to embed process management capabilities directly into your applications. This guide shows how to integrate PMDaemon\'s powerful process management features into your Rust projects.","source":"@site/docs/api/library-usage.md","sourceDirName":"api","slug":"/api/library-usage","permalink":"/pmdaemon/docs/api/library-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/entrepeneur4lyf/pmdaemon/tree/main/docs/docs/api/library-usage.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"WebSocket API","permalink":"/pmdaemon/docs/api/websocket-api"},"next":{"title":"API Examples","permalink":"/pmdaemon/docs/api/api-examples"}}');var r=s(4848),a=s(8453);const o={},i="Library Usage",c={},l=[{value:"Installation",id:"installation",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Process Manager Initialization",id:"process-manager-initialization",level:3},{value:"Process Configuration",id:"process-configuration",level:3},{value:"Advanced Usage",id:"advanced-usage",level:2},{value:"Custom Process Manager",id:"custom-process-manager",level:3},{value:"Event Handling",id:"event-handling",level:3},{value:"Integration Example",id:"integration-example",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Error Handling",id:"1-error-handling",level:3},{value:"2. Resource Management",id:"2-resource-management",level:3},{value:"3. Configuration Validation",id:"3-configuration-validation",level:3},{value:"Next Steps",id:"next-steps",level:2}];function m(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"library-usage",children:"Library Usage"})}),"\n",(0,r.jsx)(n.p,{children:"PMDaemon can be used as a Rust library, allowing you to embed process management capabilities directly into your applications. This guide shows how to integrate PMDaemon's powerful process management features into your Rust projects."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsxs)(n.p,{children:["Add PMDaemon to your ",(0,r.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'[dependencies]\npmdaemon = "0.1.1"\ntokio = { version = "1.0", features = ["full"] }\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.h3,{id:"process-manager-initialization",children:"Process Manager Initialization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessManager, ProcessConfig, HealthCheckConfig};\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Initialize the process manager\n    let mut manager = ProcessManager::new().await?;\n    \n    // Create a simple process configuration\n    let config = ProcessConfig {\n        name: "web-server".to_string(),\n        script: "node".to_string(),\n        args: vec!["server.js".to_string()],\n        instances: 2,\n        port: Some("3000-3001".to_string()),\n        env: {\n            let mut env = HashMap::new();\n            env.insert("NODE_ENV".to_string(), "production".to_string());\n            env\n        },\n        ..Default::default()\n    };\n    \n    // Start the process\n    let process_id = manager.start(config).await?;\n    println!("Started process with ID: {}", process_id);\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"process-configuration",children:"Process Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessConfig, HealthCheckConfig, HealthCheckType};\nuse std::time::Duration;\n\nfn create_web_service_config() -> ProcessConfig {\n    ProcessConfig {\n        name: "api-service".to_string(),\n        script: "node".to_string(),\n        args: vec!["dist/api.js".to_string()],\n        instances: 4,\n        port: Some("8000-8003".to_string()),\n        cwd: Some("/var/www/api".to_string()),\n        env: {\n            let mut env = std::collections::HashMap::new();\n            env.insert("NODE_ENV".to_string(), "production".to_string());\n            env.insert("DATABASE_URL".to_string(), "postgres://localhost/mydb".to_string());\n            env\n        },\n        max_memory_restart: Some("512M".to_string()),\n        autorestart: true,\n        max_restarts: 5,\n        min_uptime: Duration::from_secs(10),\n        restart_delay: Duration::from_secs(2),\n        kill_timeout: Duration::from_secs(30),\n        health_check: Some(HealthCheckConfig {\n            check_type: HealthCheckType::Http,\n            url: Some("http://localhost:8000/health".to_string()),\n            script: None,\n            timeout: Duration::from_secs(10),\n            interval: Duration::from_secs(30),\n            retries: 3,\n            enabled: true,\n        }),\n        ..Default::default()\n    }\n}\n\nfn create_worker_config() -> ProcessConfig {\n    ProcessConfig {\n        name: "background-worker".to_string(),\n        script: "python".to_string(),\n        args: vec!["-m".to_string(), "celery".to_string(), "worker".to_string(), "-A".to_string(), "tasks".to_string()],\n        instances: 2,\n        cwd: Some("/var/www/workers".to_string()),\n        env: {\n            let mut env = std::collections::HashMap::new();\n            env.insert("CELERY_BROKER_URL".to_string(), "redis://localhost:6379/0".to_string());\n            env.insert("CELERY_RESULT_BACKEND".to_string(), "redis://localhost:6379/0".to_string());\n            env\n        },\n        max_memory_restart: Some("256M".to_string()),\n        health_check: Some(HealthCheckConfig {\n            check_type: HealthCheckType::Script,\n            url: None,\n            script: Some("./scripts/worker-health.sh".to_string()),\n            timeout: Duration::from_secs(15),\n            interval: Duration::from_secs(60),\n            retries: 2,\n            enabled: true,\n        }),\n        ..Default::default()\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-usage",children:"Advanced Usage"}),"\n",(0,r.jsx)(n.h3,{id:"custom-process-manager",children:"Custom Process Manager"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessManager, ProcessConfig, ProcessStatus, ProcessInfo};\nuse tokio::time::{sleep, Duration};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct CustomProcessManager {\n    manager: ProcessManager,\n    processes: Arc<RwLock<std::collections::HashMap<String, ProcessInfo>>>,\n}\n\nimpl CustomProcessManager {\n    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {\n        let manager = ProcessManager::new().await?;\n        let processes = Arc::new(RwLock::new(std::collections::HashMap::new()));\n        \n        Ok(Self {\n            manager,\n            processes,\n        })\n    }\n    \n    pub async fn deploy_service(&mut self, name: &str, config: ProcessConfig) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83d\ude80 Deploying service: {}", name);\n        \n        // Stop existing service if it exists\n        if let Ok(_) = self.manager.get_process_info(name).await {\n            println!("\ud83d\uded1 Stopping existing service: {}", name);\n            self.manager.stop(name).await?;\n            self.wait_for_stop(name).await?;\n        }\n        \n        // Start new service\n        let process_id = self.manager.start(config.clone()).await?;\n        println!("\u2705 Started service {} with ID: {}", name, process_id);\n        \n        // Health checks are configured in the ProcessConfig\n        // The process manager handles health monitoring internally\n        \n        // Update our process tracking\n        let info = self.manager.get_process_info(name).await?;\n        self.processes.write().await.insert(name.to_string(), info);\n        \n        Ok(())\n    }\n    \n    pub async fn scale_service(&mut self, name: &str, instances: u32) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83d\udcc8 Scaling service {} to {} instances", name, instances);\n        \n        let mut config = self.manager.get_process_config(name).await?;\n        config.instances = instances;\n        \n        // Restart with new instance count\n        self.manager.restart_process_with_config(name, config).await?;\n        \n        // Wait for all instances to be healthy\n        self.manager.wait_for_healthy(name, Duration::from_secs(120)).await?;\n        \n        println!("\u2705 Service {} scaled to {} instances", name, instances);\n        Ok(())\n    }\n    \n    pub async fn rolling_update(&mut self, name: &str, new_config: ProcessConfig) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83d\udd04 Performing rolling update for service: {}", name);\n        \n        let current_info = self.manager.get_process_info(name).await?;\n        let instances = current_info.instances;\n        \n        // Update one instance at a time\n        for i in 0..instances {\n            println!("\ud83d\udd04 Updating instance {} of {}", i + 1, instances);\n            \n            // Stop one instance\n            self.manager.stop_process_instance(name, i).await?;\n            \n            // Start new instance with new config\n            self.manager.start_process_instance(name, i, new_config.clone()).await?;\n            \n            // Wait for it to be healthy\n            self.manager.wait_for_instance_healthy(name, i, Duration::from_secs(60)).await?;\n            \n            // Small delay between updates\n            sleep(Duration::from_secs(5)).await;\n        }\n        \n        println!("\u2705 Rolling update completed for service: {}", name);\n        Ok(())\n    }\n    \n    pub async fn monitor_processes(&self) -> Result<(), Box<dyn std::error::Error>> {\n        loop {\n            let processes = self.manager.list_processes().await?;\n            \n            for process in processes {\n                if process.status == ProcessStatus::Errored {\n                    println!("\u26a0\ufe0f  Process {} is in error state, attempting restart", process.name);\n                    \n                    if let Err(e) = self.manager.restart_process(&process.name).await {\n                        println!("\u274c Failed to restart {}: {}", process.name, e);\n                    } else {\n                        println!("\u2705 Restarted process: {}", process.name);\n                    }\n                }\n                \n                // Check memory usage\n                if let Some(memory_limit) = &process.max_memory_restart {\n                    let limit_bytes = parse_memory_limit(memory_limit)?;\n                    if process.memory_usage > (limit_bytes as f64 * 0.9) {\n                        println!("\u26a0\ufe0f  Process {} is approaching memory limit", process.name);\n                    }\n                }\n            }\n            \n            sleep(Duration::from_secs(30)).await;\n        }\n    }\n    \n    async fn wait_for_stop(&self, name: &str) -> Result<(), Box<dyn std::error::Error>> {\n        let timeout = Duration::from_secs(30);\n        let start = std::time::Instant::now();\n        \n        while start.elapsed() < timeout {\n            match self.manager.get_process_info(name).await {\n                Err(_) => return Ok(()), // Process not found, it\'s stopped\n                Ok(info) if info.status == ProcessStatus::Stopped => return Ok(()),\n                _ => sleep(Duration::from_secs(1)).await,\n            }\n        }\n        \n        Err("Process did not stop within timeout".into())\n    }\n}\n\nfn parse_memory_limit(limit: &str) -> Result<u64, Box<dyn std::error::Error>> {\n    let limit = limit.to_uppercase();\n    let (number, unit) = if limit.ends_with("GB") || limit.ends_with("G") {\n        (limit.trim_end_matches("GB").trim_end_matches("G").parse::<f64>()?, 1024 * 1024 * 1024)\n    } else if limit.ends_with("MB") || limit.ends_with("M") {\n        (limit.trim_end_matches("MB").trim_end_matches("M").parse::<f64>()?, 1024 * 1024)\n    } else if limit.ends_with("KB") || limit.ends_with("K") {\n        (limit.trim_end_matches("KB").trim_end_matches("K").parse::<f64>()?, 1024)\n    } else {\n        (limit.parse::<f64>()?, 1)\n    };\n    \n    Ok((number * unit as f64) as u64)\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"event-handling",children:"Event Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessManager, ProcessEvent, ProcessStatus};\nuse tokio::sync::mpsc;\n\npub struct ProcessEventHandler {\n    manager: ProcessManager,\n    event_receiver: mpsc::Receiver<ProcessEvent>,\n}\n\nimpl ProcessEventHandler {\n    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {\n        let manager = ProcessManager::new().await?;\n        let event_receiver = manager.subscribe_to_events().await?;\n        \n        Ok(Self {\n            manager,\n            event_receiver,\n        })\n    }\n    \n    pub async fn handle_events(&mut self) -> Result<(), Box<dyn std::error::Error>> {\n        while let Some(event) = self.event_receiver.recv().await {\n            match event {\n                ProcessEvent::StatusChanged { name, old_status, new_status } => {\n                    self.handle_status_change(&name, old_status, new_status).await?;\n                }\n                ProcessEvent::HealthCheckFailed { name, error } => {\n                    self.handle_health_check_failure(&name, &error).await?;\n                }\n                ProcessEvent::MemoryLimitExceeded { name, current_memory, limit } => {\n                    self.handle_memory_limit_exceeded(&name, current_memory, limit).await?;\n                }\n                ProcessEvent::ProcessCrashed { name, exit_code, signal } => {\n                    self.handle_process_crash(&name, exit_code, signal).await?;\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    async fn handle_status_change(&self, name: &str, old_status: ProcessStatus, new_status: ProcessStatus) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83d\udcca Process {} status changed: {:?} -> {:?}", name, old_status, new_status);\n        \n        match new_status {\n            ProcessStatus::Online => {\n                println!("\u2705 Process {} is now online", name);\n                self.send_notification(&format!("Process {} started successfully", name)).await?;\n            }\n            ProcessStatus::Errored => {\n                println!("\u274c Process {} has errored", name);\n                self.send_alert(&format!("Process {} has failed", name)).await?;\n            }\n            ProcessStatus::Stopped => {\n                println!("\ud83d\uded1 Process {} has stopped", name);\n            }\n            _ => {}\n        }\n        \n        Ok(())\n    }\n    \n    async fn handle_health_check_failure(&self, name: &str, error: &str) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83c\udfe5 Health check failed for {}: {}", name, error);\n        \n        // Attempt to restart the process\n        if let Err(e) = self.manager.restart_process(name).await {\n            println!("\u274c Failed to restart {} after health check failure: {}", name, e);\n            self.send_alert(&format!("Critical: Process {} health check failed and restart failed", name)).await?;\n        } else {\n            println!("\ud83d\udd04 Restarted {} due to health check failure", name);\n            self.send_notification(&format!("Process {} restarted due to health check failure", name)).await?;\n        }\n        \n        Ok(())\n    }\n    \n    async fn handle_memory_limit_exceeded(&self, name: &str, current_memory: u64, limit: u64) -> Result<(), Box<dyn std::error::Error>> {\n        println!("\ud83d\udcbe Process {} exceeded memory limit: {} > {}", name, current_memory, limit);\n        \n        // Log memory usage details\n        if let Ok(info) = self.manager.get_process_info(name).await {\n            println!("Memory details for {}: RSS={}, Heap={}", name, info.memory_usage, info.heap_usage.unwrap_or(0));\n        }\n        \n        self.send_alert(&format!("Process {} exceeded memory limit and was restarted", name)).await?;\n        \n        Ok(())\n    }\n    \n    async fn handle_process_crash(&self, name: &str, exit_code: Option<i32>, signal: Option<i32>) -> Result<(), Box<dyn std::error::Error>> {\n        let crash_info = match (exit_code, signal) {\n            (Some(code), None) => format!("exit code {}", code),\n            (None, Some(sig)) => format!("signal {}", sig),\n            (Some(code), Some(sig)) => format!("exit code {} (signal {})", code, sig),\n            (None, None) => "unknown reason".to_string(),\n        };\n        \n        println!("\ud83d\udca5 Process {} crashed: {}", name, crash_info);\n        \n        // Get crash logs\n        if let Ok(logs) = self.manager.get_process_logs(name, 50).await {\n            println!("Recent logs for {}:", name);\n            for log in logs.iter().take(10) {\n                println!("  {}", log.message);\n            }\n        }\n        \n        self.send_alert(&format!("Process {} crashed: {}", name, crash_info)).await?;\n        \n        Ok(())\n    }\n    \n    async fn send_notification(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {\n        // Implement your notification logic here\n        // This could send to Slack, email, etc.\n        println!("\ud83d\udce2 Notification: {}", message);\n        Ok(())\n    }\n    \n    async fn send_alert(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {\n        // Implement your alerting logic here\n        // This could send to PagerDuty, email, etc.\n        println!("\ud83d\udea8 Alert: {}", message);\n        Ok(())\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-example",children:"Integration Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessManager, ProcessConfig};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Clone)]\npub struct ApplicationManager {\n    process_manager: Arc<RwLock<ProcessManager>>,\n}\n\nimpl ApplicationManager {\n    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {\n        let manager = ProcessManager::new().await?;\n        \n        Ok(Self {\n            process_manager: Arc::new(RwLock::new(manager)),\n        })\n    }\n    \n    pub async fn deploy_application(&self, app_config: ApplicationConfig) -> Result<(), Box<dyn std::error::Error>> {\n        let mut manager = self.process_manager.write().await;\n        \n        // Deploy web servers\n        for (i, web_config) in app_config.web_servers.iter().enumerate() {\n            let process_config = ProcessConfig {\n                name: format!("{}-web-{}", app_config.name, i),\n                script: web_config.script.clone(),\n                args: web_config.args.clone(),\n                instances: web_config.instances,\n                port: web_config.port.clone(),\n                env: web_config.env.clone(),\n                health_check: web_config.health_check.clone(),\n                ..Default::default()\n            };\n            \n            manager.start_process(process_config).await?;\n        }\n        \n        // Deploy workers\n        for (i, worker_config) in app_config.workers.iter().enumerate() {\n            let process_config = ProcessConfig {\n                name: format!("{}-worker-{}", app_config.name, i),\n                script: worker_config.script.clone(),\n                args: worker_config.args.clone(),\n                instances: worker_config.instances,\n                env: worker_config.env.clone(),\n                health_check: worker_config.health_check.clone(),\n                ..Default::default()\n            };\n            \n            manager.start_process(process_config).await?;\n        }\n        \n        println!("\u2705 Application {} deployed successfully", app_config.name);\n        Ok(())\n    }\n    \n    pub async fn get_application_status(&self, app_name: &str) -> Result<ApplicationStatus, Box<dyn std::error::Error>> {\n        let manager = self.process_manager.read().await;\n        let processes = manager.list_processes().await?;\n        \n        let app_processes: Vec<_> = processes\n            .into_iter()\n            .filter(|p| p.name.starts_with(&format!("{}-", app_name)))\n            .collect();\n        \n        let total_processes = app_processes.len();\n        let healthy_processes = app_processes.iter().filter(|p| p.health == Some("healthy".to_string())).count();\n        let online_processes = app_processes.iter().filter(|p| p.status == ProcessStatus::Online).count();\n        \n        Ok(ApplicationStatus {\n            name: app_name.to_string(),\n            total_processes,\n            healthy_processes,\n            online_processes,\n            processes: app_processes,\n        })\n    }\n}\n\n#[derive(Debug)]\npub struct ApplicationConfig {\n    pub name: String,\n    pub web_servers: Vec<ServiceConfig>,\n    pub workers: Vec<ServiceConfig>,\n}\n\n#[derive(Debug)]\npub struct ServiceConfig {\n    pub script: String,\n    pub args: Vec<String>,\n    pub instances: u32,\n    pub port: Option<String>,\n    pub env: std::collections::HashMap<String, String>,\n    pub health_check: Option<pmdaemon::HealthCheckConfig>,\n}\n\n#[derive(Debug)]\npub struct ApplicationStatus {\n    pub name: String,\n    pub total_processes: usize,\n    pub healthy_processes: usize,\n    pub online_processes: usize,\n    pub processes: Vec<pmdaemon::ProcessInfo>,\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let app_manager = ApplicationManager::new().await?;\n    \n    // Example application configuration\n    let app_config = ApplicationConfig {\n        name: "my-web-app".to_string(),\n        web_servers: vec![\n            ServiceConfig {\n                script: "node".to_string(),\n                args: vec!["server.js".to_string()],\n                instances: 4,\n                port: Some("3000-3003".to_string()),\n                env: {\n                    let mut env = std::collections::HashMap::new();\n                    env.insert("NODE_ENV".to_string(), "production".to_string());\n                    env\n                },\n                health_check: Some(pmdaemon::HealthCheckConfig {\n                    check_type: pmdaemon::HealthCheckType::Http,\n                    url: Some("http://localhost:3000/health".to_string()),\n                    script: None,\n                    timeout: std::time::Duration::from_secs(10),\n                    interval: std::time::Duration::from_secs(30),\n                    retries: 3,\n                    enabled: true,\n                }),\n            }\n        ],\n        workers: vec![\n            ServiceConfig {\n                script: "python".to_string(),\n                args: vec!["-m".to_string(), "celery".to_string(), "worker".to_string()],\n                instances: 2,\n                port: None,\n                env: {\n                    let mut env = std::collections::HashMap::new();\n                    env.insert("CELERY_BROKER_URL".to_string(), "redis://localhost:6379".to_string());\n                    env\n                },\n                health_check: None,\n            }\n        ],\n    };\n    \n    // Deploy the application\n    app_manager.deploy_application(app_config).await?;\n    \n    // Check application status\n    let status = app_manager.get_application_status("my-web-app").await?;\n    println!("Application status: {:?}", status);\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-error-handling",children:"1. Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use pmdaemon::{ProcessManager, PMDaemonError};\n\nasync fn robust_process_management() -> Result<(), Box<dyn std::error::Error>> {\n    let mut manager = ProcessManager::new().await?;\n    \n    match manager.start_process(config).await {\n        Ok(process_id) => {\n            println!("Process started with ID: {}", process_id);\n        }\n        Err(PMDaemonError::ProcessAlreadyExists(name)) => {\n            println!("Process {} already exists, restarting...", name);\n            manager.restart(&name).await?;\n        }\n        Err(PMDaemonError::PortConflict(port)) => {\n            println!("Port {} is in use, trying auto-assignment...", port);\n            // Retry with auto port assignment\n        }\n        Err(e) => {\n            return Err(e.into());\n        }\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-resource-management",children:"2. Resource Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use pmdaemon::ProcessManager;\nuse std::sync::Arc;\n\n// Use Arc for shared ownership\nlet manager = Arc::new(ProcessManager::new().await?);\n\n// Clone for use in different tasks\nlet manager_clone = Arc::clone(&manager);\ntokio::spawn(async move {\n    // Use manager_clone in this task\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-configuration-validation",children:"3. Configuration Validation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use pmdaemon::{ProcessConfig, ConfigValidator};\n\nfn validate_config(config: &ProcessConfig) -> Result<(), String> {\n    let validator = ConfigValidator::new();\n    validator.validate(config)\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/api/api-examples",children:"API Examples"})})," - REST and WebSocket API usage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/api/websocket-api",children:"WebSocket API"})})," - Real-time communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/examples/integration-examples",children:"Integration Examples"})})," - Framework integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/configuration/advanced-configuration",children:"Advanced Configuration"})})," - Complex configurations"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>i});var t=s(6540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);