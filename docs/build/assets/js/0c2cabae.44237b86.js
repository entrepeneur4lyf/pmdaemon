"use strict";(self.webpackChunkpmdaemon_docs=self.webpackChunkpmdaemon_docs||[]).push([[2530],{8263:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api/api-examples","title":"API Examples","description":"This guide provides practical examples of using PMDaemon\'s REST and WebSocket APIs in various programming languages and scenarios. From simple process management to complex monitoring dashboards, these examples will help you integrate PMDaemon into your applications.","source":"@site/docs/api/api-examples.md","sourceDirName":"api","slug":"/api/api-examples","permalink":"/pmdaemon/docs/api/api-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/entrepeneur4lyf/pmdaemon/tree/main/docs/docs/api/api-examples.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Library Usage","permalink":"/pmdaemon/docs/api/library-usage"},"next":{"title":"Real-World Use Cases","permalink":"/pmdaemon/docs/examples/use-cases"}}');var r=s(4848),o=s(8453);const a={},i="API Examples",c={},l=[{value:"REST API Examples",id:"rest-api-examples",level:2},{value:"JavaScript/Node.js",id:"javascriptnodejs",level:3},{value:"Basic Process Management",id:"basic-process-management",level:4},{value:"Deployment Automation",id:"deployment-automation",level:4},{value:"Python",id:"python",level:3},{value:"Process Management with Error Handling",id:"process-management-with-error-handling",level:4},{value:"Go",id:"go",level:3},{value:"Simple Process Management",id:"simple-process-management",level:4},{value:"WebSocket API Examples",id:"websocket-api-examples",level:2},{value:"Real-time Dashboard",id:"real-time-dashboard",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"api-examples",children:"API Examples"})}),"\n",(0,r.jsx)(n.p,{children:"This guide provides practical examples of using PMDaemon's REST and WebSocket APIs in various programming languages and scenarios. From simple process management to complex monitoring dashboards, these examples will help you integrate PMDaemon into your applications."}),"\n",(0,r.jsx)(n.h2,{id:"rest-api-examples",children:"REST API Examples"}),"\n",(0,r.jsx)(n.h3,{id:"javascriptnodejs",children:"JavaScript/Node.js"}),"\n",(0,r.jsx)(n.h4,{id:"basic-process-management",children:"Basic Process Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const axios = require('axios');\n\nclass PMDaemonClient {\n  constructor(baseURL = 'http://localhost:9615', apiKey = null) {\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    \n    // Add authentication header if API key provided\n    if (apiKey) {\n      headers['Authorization'] = `Bearer ${apiKey}`;\n    }\n    \n    this.api = axios.create({\n      baseURL,\n      timeout: 10000,\n      headers\n    });\n  }\n\n  async listProcesses() {\n    try {\n      const response = await this.api.get('/api/processes');\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to list processes: ${error.message}`);\n    }\n  }\n\n  async startProcess(nameOrId) {\n    try {\n      const response = await this.api.post(`/api/processes/${nameOrId}/start`);\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to start process: ${error.message}`);\n    }\n  }\n\n  async stopProcess(nameOrId) {\n    try {\n      const response = await this.api.delete(`/api/processes/${nameOrId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to stop process: ${error.message}`);\n    }\n  }\n\n  async restartProcess(nameOrId, config = {}) {\n    try {\n      const response = await this.api.post(`/api/processes/${nameOrId}/restart`, config);\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to restart process: ${error.message}`);\n    }\n  }\n\n  async getProcessInfo(nameOrId) {\n    try {\n      const response = await this.api.get(`/api/processes/${nameOrId}`);\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get process info: ${error.message}`);\n    }\n  }\n\n  async getSystemMetrics() {\n    try {\n      const response = await this.api.get('/api/system');\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get system metrics: ${error.message}`);\n    }\n  }\n\n  async getProcessLogs(nameOrId, lines = 20, type = 'all') {\n    try {\n      const response = await this.api.get(`/api/logs/${nameOrId}`, {\n        params: { lines, type }\n      });\n      return response.data;\n    } catch (error) {\n      throw new Error(`Failed to get process logs: ${error.message}`);\n    }\n  }\n}\n\n// Usage example\nasync function main() {\n  // Create client with API key authentication\n  const client = new PMDaemonClient('http://localhost:9615', 'your-api-key');\n\n  try {\n    // Start an existing process (processes must be created via CLI)\n    const startResult = await client.startProcess('test-api');\n    console.log('Process started:', startResult);\n\n    // Wait a moment for the process to start\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Get process information\n    const processInfo = await client.getProcessInfo('test-api');\n    console.log('Process info:', processInfo);\n\n    // Get system metrics\n    const systemMetrics = await client.getSystemMetrics();\n    console.log('System metrics:', systemMetrics);\n\n    // Get process logs\n    const logs = await client.getProcessLogs('test-api', 50);\n    console.log('Process logs:', logs);\n\n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\nmain();\n"})}),"\n",(0,r.jsx)(n.h4,{id:"deployment-automation",children:"Deployment Automation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const PMDaemonClient = require('./pmdaemon-client');\n\nclass DeploymentManager {\n  constructor(apiUrl) {\n    this.client = new PMDaemonClient(apiUrl);\n  }\n\n  async deployService(serviceName, config, healthCheckUrl) {\n    console.log(`\ud83d\ude80 Deploying ${serviceName}...`);\n\n    try {\n      // Stop existing service if it exists\n      try {\n        await this.client.stopProcess(serviceName);\n        console.log(`\u2705 Stopped existing ${serviceName}`);\n        await this.waitForProcessStop(serviceName);\n      } catch (error) {\n        // Process might not exist, continue\n      }\n\n      // Start new service\n      const startResult = await this.client.startProcess({\n        name: serviceName,\n        ...config\n      });\n\n      if (!startResult.success) {\n        throw new Error(`Failed to start ${serviceName}: ${startResult.message}`);\n      }\n\n      // Wait for service to be healthy\n      if (healthCheckUrl) {\n        await this.waitForHealthy(serviceName, healthCheckUrl);\n      }\n\n      console.log(`\u2705 ${serviceName} deployed successfully`);\n      return true;\n\n    } catch (error) {\n      console.error(`\u274c Failed to deploy ${serviceName}:`, error.message);\n      \n      // Get logs for debugging\n      try {\n        const logs = await this.client.getProcessLogs(serviceName, 20);\n        console.log('Recent logs:', logs.logs.map(log => log.message).join('\\n'));\n      } catch (logError) {\n        console.error('Could not retrieve logs:', logError.message);\n      }\n\n      throw error;\n    }\n  }\n\n  async waitForProcessStop(serviceName, timeout = 30000) {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      try {\n        await this.client.getProcessInfo(serviceName);\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      } catch (error) {\n        // Process not found, it's stopped\n        return;\n      }\n    }\n    \n    throw new Error(`Process ${serviceName} did not stop within ${timeout}ms`);\n  }\n\n  async waitForHealthy(serviceName, healthCheckUrl, timeout = 60000) {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      try {\n        const processInfo = await this.client.getProcessInfo(serviceName);\n        \n        if (processInfo.status === 'online' && processInfo.health === 'healthy') {\n          return;\n        }\n        \n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    throw new Error(`Service ${serviceName} did not become healthy within ${timeout}ms`);\n  }\n\n  async blueGreenDeploy(serviceName, config, healthCheckUrl) {\n    const currentColor = await this.getCurrentColor(serviceName);\n    const newColor = currentColor === 'blue' ? 'green' : 'blue';\n    const newServiceName = `${serviceName}-${newColor}`;\n\n    console.log(`\ud83d\udd04 Blue-green deployment: ${currentColor} -> ${newColor}`);\n\n    // Deploy to new color\n    await this.deployService(newServiceName, config, healthCheckUrl);\n\n    // Switch traffic (this would integrate with your load balancer)\n    console.log(`\ud83d\udd00 Switching traffic to ${newColor}`);\n    \n    // Wait for traffic to drain\n    await new Promise(resolve => setTimeout(resolve, 10000));\n\n    // Stop old color\n    if (currentColor) {\n      const oldServiceName = `${serviceName}-${currentColor}`;\n      await this.client.stopProcess(oldServiceName);\n      console.log(`\ud83d\uded1 Stopped old deployment: ${oldServiceName}`);\n    }\n\n    console.log(`\u2705 Blue-green deployment complete`);\n  }\n\n  async getCurrentColor(serviceName) {\n    try {\n      const processes = await this.client.listProcesses();\n      const blueExists = processes.processes.some(p => p.name === `${serviceName}-blue`);\n      const greenExists = processes.processes.some(p => p.name === `${serviceName}-green`);\n      \n      if (blueExists) return 'blue';\n      if (greenExists) return 'green';\n      return null;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\n// Usage\nasync function deployExample() {\n  const deployer = new DeploymentManager('http://localhost:9615');\n\n  const serviceConfig = {\n    script: 'node',\n    args: ['dist/server.js'],\n    instances: 2,\n    port: '3000-3001',\n    env: {\n      NODE_ENV: 'production',\n      DATABASE_URL: 'postgres://localhost/myapp'\n    },\n    health_check: {\n      check_type: 'http',\n      url: 'http://localhost:3000/health',\n      enabled: true\n    }\n  };\n\n  await deployer.blueGreenDeploy('web-api', serviceConfig, 'http://localhost:3000/health');\n}\n\ndeployExample().catch(console.error);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,r.jsx)(n.h4,{id:"process-management-with-error-handling",children:"Process Management with Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import requests\nimport time\nimport json\nfrom typing import Dict, List, Optional\n\nclass PMDaemonClient:\n    def __init__(self, base_url: str = \"http://localhost:9615\"):\n        self.base_url = base_url.rstrip('/')\n        self.session = requests.Session()\n        self.session.headers.update({\n            'Content-Type': 'application/json'\n        })\n\n    def _request(self, method: str, endpoint: str, **kwargs) -> Dict:\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            raise Exception(f\"API request failed: {e}\")\n\n    def list_processes(self) -> Dict:\n        return self._request('GET', '/api/processes')\n\n    def start_process(self, config: Dict) -> Dict:\n        return self._request('POST', '/api/processes', json=config)\n\n    def stop_process(self, name_or_id: str) -> Dict:\n        return self._request('DELETE', f'/api/processes/{name_or_id}')\n\n    def restart_process(self, name_or_id: str, config: Optional[Dict] = None) -> Dict:\n        return self._request('POST', f'/api/processes/{name_or_id}/restart', \n                           json=config or {})\n\n    def get_process_info(self, name_or_id: str) -> Dict:\n        return self._request('GET', f'/api/processes/{name_or_id}')\n\n    def get_system_metrics(self) -> Dict:\n        return self._request('GET', '/api/system')\n\n    def get_process_logs(self, name_or_id: str, lines: int = 20, \n                        log_type: str = 'all') -> Dict:\n        params = {'lines': lines, 'type': log_type}\n        return self._request('GET', f'/api/logs/{name_or_id}', params=params)\n\n    def wait_for_process_status(self, name_or_id: str, expected_status: str, \n                               timeout: int = 30) -> bool:\n        \"\"\"Wait for a process to reach a specific status\"\"\"\n        start_time = time.time()\n        \n        while time.time() - start_time < timeout:\n            try:\n                info = self.get_process_info(name_or_id)\n                if info.get('status') == expected_status:\n                    return True\n            except Exception:\n                pass\n            time.sleep(1)\n        \n        return False\n\n    def wait_for_healthy(self, name_or_id: str, timeout: int = 60) -> bool:\n        \"\"\"Wait for a process to become healthy\"\"\"\n        start_time = time.time()\n        \n        while time.time() - start_time < timeout:\n            try:\n                info = self.get_process_info(name_or_id)\n                if (info.get('status') == 'online' and \n                    info.get('health') == 'healthy'):\n                    return True\n            except Exception:\n                pass\n            time.sleep(2)\n        \n        return False\n\nclass ProcessMonitor:\n    def __init__(self, client: PMDaemonClient):\n        self.client = client\n\n    def check_process_health(self, process_name: str) -> Dict:\n        \"\"\"Check the health of a specific process\"\"\"\n        try:\n            info = self.client.get_process_info(process_name)\n            \n            health_status = {\n                'name': process_name,\n                'status': info.get('status'),\n                'health': info.get('health'),\n                'cpu': info.get('cpu'),\n                'memory': info.get('memory'),\n                'uptime': info.get('uptime'),\n                'restarts': info.get('restarts'),\n                'healthy': info.get('status') == 'online' and info.get('health') == 'healthy'\n            }\n            \n            return health_status\n            \n        except Exception as e:\n            return {\n                'name': process_name,\n                'status': 'unknown',\n                'healthy': False,\n                'error': str(e)\n            }\n\n    def monitor_processes(self, process_names: List[str]) -> Dict:\n        \"\"\"Monitor multiple processes and return their health status\"\"\"\n        results = {}\n        \n        for process_name in process_names:\n            results[process_name] = self.check_process_health(process_name)\n        \n        return results\n\n    def restart_unhealthy_processes(self, process_names: List[str]) -> Dict:\n        \"\"\"Restart any unhealthy processes\"\"\"\n        results = {}\n        \n        for process_name in process_names:\n            health = self.check_process_health(process_name)\n            \n            if not health.get('healthy', False):\n                print(f\"\ud83d\udd04 Restarting unhealthy process: {process_name}\")\n                try:\n                    restart_result = self.client.restart_process(process_name)\n                    \n                    # Wait for process to become healthy\n                    if self.client.wait_for_healthy(process_name, timeout=60):\n                        results[process_name] = {'status': 'restarted', 'healthy': True}\n                        print(f\"\u2705 {process_name} restarted successfully\")\n                    else:\n                        results[process_name] = {'status': 'restart_failed', 'healthy': False}\n                        print(f\"\u274c {process_name} restart failed\")\n                        \n                except Exception as e:\n                    results[process_name] = {'status': 'error', 'error': str(e)}\n                    print(f\"\u274c Error restarting {process_name}: {e}\")\n            else:\n                results[process_name] = {'status': 'healthy', 'healthy': True}\n        \n        return results\n\n# Usage example\ndef main():\n    client = PMDaemonClient()\n    monitor = ProcessMonitor(client)\n\n    # Deploy a new service\n    service_config = {\n        'name': 'python-api',\n        'script': 'python',\n        'args': ['-m', 'uvicorn', 'main:app', '--host', '0.0.0.0', '--port', '8000'],\n        'port': '8000',\n        'env': {\n            'PYTHONPATH': '/app',\n            'DATABASE_URL': 'postgres://localhost/myapp'\n        },\n        'health_check': {\n            'check_type': 'http',\n            'url': 'http://localhost:8000/health',\n            'timeout': 10,\n            'interval': 30,\n            'enabled': True\n        }\n    }\n\n    try:\n        # Start the service\n        print(\"\ud83d\ude80 Starting Python API service...\")\n        result = client.start_process(service_config)\n        print(f\"Start result: {result}\")\n\n        # Wait for it to become healthy\n        if client.wait_for_healthy('python-api', timeout=60):\n            print(\"\u2705 Service is healthy\")\n        else:\n            print(\"\u274c Service failed to become healthy\")\n            logs = client.get_process_logs('python-api', lines=20)\n            print(\"Recent logs:\")\n            for log in logs.get('logs', []):\n                print(f\"  {log.get('message', '')}\")\n\n        # Monitor the service\n        health_status = monitor.check_process_health('python-api')\n        print(f\"Health status: {health_status}\")\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"go",children:"Go"}),"\n",(0,r.jsx)(n.h4,{id:"simple-process-management",children:"Simple Process Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "bytes"\n    "encoding/json"\n    "fmt"\n    "io"\n    "net/http"\n    "time"\n)\n\ntype PMDaemonClient struct {\n    BaseURL string\n    Client  *http.Client\n}\n\ntype ProcessConfig struct {\n    Name      string            `json:"name"`\n    Script    string            `json:"script"`\n    Args      []string          `json:"args,omitempty"`\n    Port      string            `json:"port,omitempty"`\n    Instances int               `json:"instances,omitempty"`\n    Env       map[string]string `json:"env,omitempty"`\n}\n\ntype ProcessInfo struct {\n    ID       int    `json:"id"`\n    Name     string `json:"name"`\n    Status   string `json:"status"`\n    PID      int    `json:"pid"`\n    Port     int    `json:"port"`\n    CPU      float64 `json:"cpu"`\n    Memory   int64  `json:"memory"`\n    Uptime   int64  `json:"uptime"`\n    Restarts int    `json:"restarts"`\n    Health   string `json:"health"`\n}\n\ntype ProcessListResponse struct {\n    Processes []ProcessInfo `json:"processes"`\n    Total     int           `json:"total"`\n}\n\nfunc NewPMDaemonClient(baseURL string) *PMDaemonClient {\n    return &PMDaemonClient{\n        BaseURL: baseURL,\n        Client: &http.Client{\n            Timeout: 30 * time.Second,\n        },\n    }\n}\n\nfunc (c *PMDaemonClient) request(method, endpoint string, body interface{}) (*http.Response, error) {\n    var reqBody io.Reader\n    \n    if body != nil {\n        jsonData, err := json.Marshal(body)\n        if err != nil {\n            return nil, err\n        }\n        reqBody = bytes.NewBuffer(jsonData)\n    }\n    \n    req, err := http.NewRequest(method, c.BaseURL+endpoint, reqBody)\n    if err != nil {\n        return nil, err\n    }\n    \n    req.Header.Set("Content-Type", "application/json")\n    \n    return c.Client.Do(req)\n}\n\nfunc (c *PMDaemonClient) ListProcesses() (*ProcessListResponse, error) {\n    resp, err := c.request("GET", "/api/processes", nil)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n    \n    var result ProcessListResponse\n    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n        return nil, err\n    }\n    \n    return &result, nil\n}\n\nfunc (c *PMDaemonClient) StartProcess(config ProcessConfig) error {\n    resp, err := c.request("POST", "/api/processes", config)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    \n    if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {\n        return fmt.Errorf("failed to start process: status %d", resp.StatusCode)\n    }\n    \n    return nil\n}\n\nfunc (c *PMDaemonClient) StopProcess(nameOrID string) error {\n    resp, err := c.request("DELETE", "/api/processes/"+nameOrID, nil)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    \n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf("failed to stop process: status %d", resp.StatusCode)\n    }\n    \n    return nil\n}\n\nfunc (c *PMDaemonClient) GetProcessInfo(nameOrID string) (*ProcessInfo, error) {\n    resp, err := c.request("GET", "/api/processes/"+nameOrID, nil)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n    \n    var result ProcessInfo\n    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {\n        return nil, err\n    }\n    \n    return &result, nil\n}\n\nfunc (c *PMDaemonClient) WaitForHealthy(nameOrID string, timeout time.Duration) error {\n    start := time.Now()\n    \n    for time.Since(start) < timeout {\n        info, err := c.GetProcessInfo(nameOrID)\n        if err == nil && info.Status == "online" && info.Health == "healthy" {\n            return nil\n        }\n        \n        time.Sleep(2 * time.Second)\n    }\n    \n    return fmt.Errorf("process %s did not become healthy within %v", nameOrID, timeout)\n}\n\nfunc main() {\n    client := NewPMDaemonClient("http://localhost:9615")\n    \n    // Start a new process\n    config := ProcessConfig{\n        Name:   "go-api",\n        Script: "go",\n        Args:   []string{"run", "main.go"},\n        Port:   "8080",\n        Env: map[string]string{\n            "GO_ENV": "production",\n        },\n    }\n    \n    fmt.Println("\ud83d\ude80 Starting Go API service...")\n    if err := client.StartProcess(config); err != nil {\n        fmt.Printf("\u274c Failed to start process: %v\\n", err)\n        return\n    }\n    \n    // Wait for it to become healthy\n    fmt.Println("\u23f3 Waiting for service to become healthy...")\n    if err := client.WaitForHealthy("go-api", 60*time.Second); err != nil {\n        fmt.Printf("\u274c Service failed to become healthy: %v\\n", err)\n        return\n    }\n    \n    fmt.Println("\u2705 Service is healthy!")\n    \n    // List all processes\n    processes, err := client.ListProcesses()\n    if err != nil {\n        fmt.Printf("\u274c Failed to list processes: %v\\n", err)\n        return\n    }\n    \n    fmt.Printf("\ud83d\udccb Found %d processes:\\n", processes.Total)\n    for _, proc := range processes.Processes {\n        fmt.Printf("  - %s (PID: %d, Status: %s, Health: %s)\\n", \n                   proc.Name, proc.PID, proc.Status, proc.Health)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"websocket-api-examples",children:"WebSocket API Examples"}),"\n",(0,r.jsx)(n.h3,{id:"real-time-dashboard",children:"Real-time Dashboard"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// dashboard.js\nclass PMDaemonDashboard {\n  constructor(wsUrl = 'ws://localhost:9615/ws') {\n    this.wsUrl = wsUrl;\n    this.ws = null;\n    this.processes = new Map();\n    this.systemMetrics = {};\n  }\n\n  connect() {\n    this.ws = new WebSocket(this.wsUrl);\n    \n    this.ws.onopen = () => {\n      console.log('Connected to PMDaemon WebSocket');\n      this.subscribe();\n    };\n\n    this.ws.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      this.handleMessage(message);\n    };\n\n    this.ws.onclose = () => {\n      console.log('WebSocket connection closed');\n      // Attempt to reconnect after 5 seconds\n      setTimeout(() => this.connect(), 5000);\n    };\n\n    this.ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n    };\n  }\n\n  subscribe() {\n    this.send('subscribe', {\n      events: ['process_status', 'process_metrics', 'system_metrics', 'health_update'],\n      interval: 1000\n    });\n  }\n\n  send(type, data) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({ type, data }));\n    }\n  }\n\n  handleMessage(message) {\n    switch (message.type) {\n      case 'process_status':\n        this.updateProcessStatus(message.data);\n        break;\n      case 'process_metrics':\n        this.updateProcessMetrics(message.data);\n        break;\n      case 'system_metrics':\n        this.updateSystemMetrics(message.data);\n        break;\n      case 'health_update':\n        this.updateProcessHealth(message.data);\n        break;\n    }\n  }\n\n  updateProcessStatus(data) {\n    const process = this.processes.get(data.name) || {};\n    process.status = data.status;\n    process.pid = data.pid;\n    process.port = data.port;\n    this.processes.set(data.name, process);\n    this.renderProcesses();\n  }\n\n  updateProcessMetrics(data) {\n    data.processes.forEach(proc => {\n      const process = this.processes.get(proc.name) || {};\n      Object.assign(process, proc);\n      this.processes.set(proc.name, process);\n    });\n    this.renderProcesses();\n  }\n\n  updateSystemMetrics(data) {\n    this.systemMetrics = data;\n    this.renderSystemMetrics();\n  }\n\n  updateProcessHealth(data) {\n    const process = this.processes.get(data.process) || {};\n    process.health = data.status;\n    this.processes.set(data.process, process);\n    this.renderProcesses();\n  }\n\nrenderProcesses() {\n    const container = document.getElementById('processes');\n   container.innerHTML = '';\n   \n   Array.from(this.processes.values()).forEach(proc => {\n     const card = document.createElement('div');\n     card.className = `process-card ${proc.status} ${proc.health}`;\n     \n     const nameEl = document.createElement('h3');\n     nameEl.textContent = proc.name;\n     card.appendChild(nameEl);\n     \n     const statusEl = document.createElement('div');\n     statusEl.className = 'status';\n     statusEl.textContent = `Status: ${proc.status}`;\n     card.appendChild(statusEl);\n     \n     // Continue with other elements...\n     container.appendChild(card);\n   });\n        <div class=\"metrics\">\n          <span>CPU: ${proc.cpu?.toFixed(1) || 0}%</span>\n          <span>Memory: ${proc.memory ? (proc.memory / 1024 / 1024).toFixed(1) : 0}MB</span>\n          <span>PID: ${proc.pid || 'N/A'}</span>\n          <span>Port: ${proc.port || 'N/A'}</span>\n        </div>\n        <div class=\"actions\">\n          <button onclick=\"dashboard.restartProcess('${proc.name}')\">Restart</button>\n          <button onclick=\"dashboard.stopProcess('${proc.name}')\">Stop</button>\n        </div>\n      </div>\n    `).join('');\n  }\n\n  renderSystemMetrics() {\n    const container = document.getElementById('system-metrics');\n    const metrics = this.systemMetrics;\n    \n    container.innerHTML = `\n      <div class=\"metric\">\n        <h4>CPU Usage</h4>\n        <div class=\"value\">${metrics.cpu?.usage?.toFixed(1) || 0}%</div>\n      </div>\n      <div class=\"metric\">\n        <h4>Memory Usage</h4>\n        <div class=\"value\">${metrics.memory?.usage_percent?.toFixed(1) || 0}%</div>\n      </div>\n      <div class=\"metric\">\n        <h4>Load Average</h4>\n        <div class=\"value\">${metrics.load?.one?.toFixed(2) || 0}</div>\n      </div>\n    `;\n  }\n\n  restartProcess(name) {\n    this.send('command', {\n      action: 'restart',\n      process: name\n    });\n  }\n\n  stopProcess(name) {\n    this.send('command', {\n      action: 'stop',\n      process: name\n    });\n  }\n}\n\n// Initialize dashboard\nconst dashboard = new PMDaemonDashboard();\ndashboard.connect();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/api/library-usage",children:"Library Usage"})})," - Using PMDaemon as a Rust library"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/api/websocket-api",children:"WebSocket API"})})," - Real-time WebSocket communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/api/rest-api",children:"REST API"})})," - Complete HTTP API reference"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"/pmdaemon/docs/examples/integration-examples",children:"Integration Examples"})})," - Framework-specific integration"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(6540);const r={},o=t.createContext(r);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);